---
title: "[Go/LeetCode] 21. Merge Two Sorted Lists"
emoji: "ğŸƒ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "leetcode"]
published: true
publication_name: "progate_users"
---

# æ¦‚è¦
â†“ã®è§£æ³•ãƒ¡ãƒ¢ã§ã™ã€‚
https://leetcode.com/problems/merge-two-sorted-lists/description/

# å•é¡Œæ¦‚è¦
äºŒã¤ã®ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆãŒæ¸¡ã•ã‚Œã‚‹ã®ã§ã€ã“ã‚Œã‚’ãƒãƒ¼ã‚¸ã—ã¾ã™ã€‚
ä¾‹ãˆã° `[1,2,4]` ã¨ `[1,3,4]` ãŒæ¸¡ã•ã‚ŒãŸã¨ãã€`[1,1,2,3,4,4]` ã‚’è¿”ã—ã¾ã™ã€‚

æ³¨æ„ç‚¹ã¨ã—ã¦ã€ãŸã ã®ã‚¹ãƒ©ã‚¤ã‚¹ãŒæ¸¡ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**æ¬¡ã®è¦ç´ ã¸ã®å‚ç…§ã‚’æŒã£ãŸã€ãƒªã‚¹ãƒˆå…ˆé ­ã®ãƒãƒ¼ãƒ‰** ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚

```go
 type ListNode struct {
     Val int
     Next *ListNode
 }
```

# è§£æ³•
## åˆè¦‹
ã‚„ã‚‹ã“ã¨ã¯ã‚·ãƒ³ãƒ—ãƒ«ã§ã€ãƒªã‚¹ãƒˆã®é ­ã‹ã‚‰å°ã•ã„ã»ã†ã‚’å–ã‚Šå‡ºã—ã¦æ–°ã—ã„ãƒªã‚¹ãƒˆã«å…¥ã‚Œã‚‹ã ã‘ã§ã™ã€‚
ãã®ã¾ã¾ã§ã¯æ‰±ã„ã¥ã‚‰ã„ã®ã§ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚ˆã‚ã—ãã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚ˆã†ã«å‚ç…§ã§ãã‚‹ã‚ˆã† `byIndex` é–¢æ•°ã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚ã¾ãŸã€ã€Œé…åˆ—ã®é ­ã®è¦ç´ ã‚’å–ã‚Šå‡ºã™ã€ã€Œå¤‰æ•°ã®å‚ç…§å…ˆã‚’æ¬¡ã®è¦ç´ ã«ç§»ã™ã€æ“ä½œã‚’ã¾ã¨ã‚ã‚‹ `pop` ã‚‚å®Ÿè£…ã—ã¾ã—ãŸã€‚

```go
func byIndex(list *ListNode, i int) *ListNode {
    if i == 0 {
        return list
    }
    if list.Next == nil {
        return nil
    }
    return byIndex(list.Next, i-1)
}
func pop(list *ListNode) (*ListNode, *ListNode) {
    p := list
    list = list.Next
    return p, list
}

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    var mergedListNode *ListNode
    if list1 == nil && list2 == nil {
        return nil
    } else if  list1 != nil && list2 == nil {
        mergedListNode, list1 = pop(list1)
    } else if  list1 == nil && list2 != nil {
        mergedListNode, list2 = pop(list2)
    } else {
        if list1.Val < list2.Val {
            mergedListNode, list1 = pop(list1)
        } else {
            mergedListNode, list2 = pop(list2)
        }
    }

    for i:=0; list1 != nil || list2 != nil; i++ {
        if list1 != nil && list2 == nil {
            byIndex(mergedListNode, i).Next, list1 = pop(list1)
            continue
        } 
        if list1 == nil && list2 != nil {
            byIndex(mergedListNode, i).Next, list2 = pop(list2)
            continue
        }

        if list1.Val < list2.Val {
            byIndex(mergedListNode, i).Next, list1 = pop(list1)
            continue
        } else {
            byIndex(mergedListNode, i).Next, list2 = pop(list2)
            continue
        }
    }

    return mergedListNode
}
```

åçœã¨ã—ã¦ã¯å…¨ãåŒã˜æ¡ä»¶å¼ãŒ2é‡ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹éƒ¨åˆ†ã§ã—ã‚‡ã†ã‹ã€‚ã©ã†ã«ã‹ã¾ã¨ã‚ãŸã‹ã£ãŸã§ã™ãŒã€æ¡ä»¶å¼å†…éƒ¨ã§ã‚„ã£ã¦ã„ã‚‹å‡¦ç†ãŒåˆ¥ç‰©ãªã®ã§ã‚„ã‚Šã¥ã‚‰ã„ãªï½ã¨æ€ã„ãã®ã¾ã¾ã«ã—ã¦ã„ã¾ã™ã€‚
`byIndex` ã§æ¯å›é ­ã‹ã‚‰è¦ç´ ã‚’æ¢ç´¢ã—ã¦ã‚‹ã®ã‚‚ã‹ãªã‚Šç„¡é§„ãã†ã€‚æœ€çµ‚çš„ã«è¿”ã—ãŸã„ã®ãŒé…åˆ—ã®å…ˆé ­ãƒãƒ¼ãƒ‰ãªã®ã§ `mergedListNode` ãŒé ­ã®å‚ç…§ã‚’ã‚­ãƒ¼ãƒ—ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã¾ã—ãŸãŒã€ã‚‚ã£ã¨ã„ã„æ›¸ãæ–¹ãŒã‚ã‚Šã¾ã—ãŸã€‚

## æœ€é©åŒ–
Solutions ã‹ã‚‰å¼•ç”¨ã•ã›ã¦ã‚‚ã‚‰ã„ã¾ã™ã€‚
https://leetcode.com/problems/merge-two-sorted-lists/solutions/6251904/best-solution-ever-python-java-c-c-javascript-go-c-kotlin-typescript-swift

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{}
    op := dummy

    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            op.Next = list1
            list1 = list1.Next
        } else {
            op.Next = list2
            list2 = list2.Next
        }
        op = op.Next
    }
    if list1 != nil {
        op.Next = list1
    }
    if list2 != nil {
        op.Next = list2
    }
    return dummy.Next
}
```

è¿”ã™è¦ç´ ã®é ­ã¸ã®å‚ç…§ã¯ `dummy` ã«æŒã¡ã¤ã¤ã€ä½œæ¥­ç”¨ã®ãƒã‚¤ãƒ³ã‚¿ã‚’åˆ¥ã«ä½œã£ã¦ä½œæ¥­ã—ã¦ã¾ã™ã€‚å…¨ç„¶ã“ã‚Œã§ã‚ˆã‹ã£ãŸã€‚
Go ã§æ§‹é€ ä½“ã‚’ãƒªãƒ†ãƒ©ãƒ«ã‹ã‚‰åˆæœŸåŒ–ã™ã‚‹ã¨ã‚¼ãƒ­å€¤ã§åˆæœŸåŒ–ã•ã‚Œã¦ã—ã¾ã†ã®ã§åˆæœŸåŒ–å‡¦ç†ã‚’åˆ¥ã«æ›¸ã„ã¦ã„ã¾ã—ãŸãŒã€åˆ¥ã«ãƒã‚¤ãƒ³ã‚¿ã‚’æŒã¦ã°ã“ã‚Œã‚‚è§£æ±ºã—ã¾ã—ãŸã€‚ã‚¹ãƒƒã‚­ãƒªã€‚